%%
%% This is file `sample-sigconf-i13n.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf-i13n')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf-i13n.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[a4paper,sigconf, language=french,
language=german, language=spanish, language=english]{acmart}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{rightsretained}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{}

%% These commands are for a PROCEEDINGS abstract or paper.

\acmConference[Colloquium on Vulnerability Discovery 2022]{Colloquium on Vulnerability Discovery 2022}{August 1st, 2022}{KIT, Karlsruhe, Germany}
\acmPrice{00.00}
\acmISBN{}

\settopmatter{printacmref=false}

\settopmatter{printccs=false}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\input{solidity-highlighting.tex}	
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Finding Vulnerabilities in Smart Contracts}


%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Michele Massetti}
\email{big.michelemassetti@gmail.com}
\affiliation{%
  \institution{Karlsruhe Institute of Technologies}
  \city{Karlsruhe}
  \state{Baden-Württemberg}
  \country{Germany}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Massetti.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Blockchain is a revolutionary technology that enables users to communicate in a trust-less manner. 
The most prominent change brought by this technology is the mode of business between organizations: they do not need anymore a trusted third party. 
It is a distributed ledger technology based on a decentralized peer-to-peer (P2P) network. 
Since Bitcoin was deployed, many blockchain systems have been born with more capabilities, which have allowed them to fit many
different use cases. Smart Contracts, which are programs running on blockchain systems, could extend the potentiality of blockchain
from a platform for financial transactions to an all-purpose utility.
The development of innovative and prominent applications is a consequence of them, such as NFT marketplaces, music royalty tracking, supply chain and logistics monitoring, voting mechanism, 
cross-border payments, and many others.
Finding bugs and vulnerabilities in them is necessary for assuring their correct behaviour. 
This paper deals with the way for finding the vulnerabilities in Ethereum blockchain-based smart contracts. We review related works regarding 
the classification of the most common vulnerabilities and tools which support their detection.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Solidity, Software, Vulnerability, Blockchain}


%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
Nowadays, the major platform for decentralized decentralized ﬁnance (DeFi) 
and applications (dApps) is Ethereum. It can be described as the "internet of Blockchain".
Its ecosystem consists of the underlying blockchain, a large
variety of smart contracts deployed on it, a wide range of
valuable assets. 

This growing technology has attaracted many investors, indeed, according \href{https://www.coingecko.com/}{CoinGeko}, 
the crypto market's value is standing around \$2 trillion.
On the other hand, interest in such a market has grown even among malicious attackers. 
Attacks such as the “Parity Wallet Hack” and the “Decentralized Autonomous Organization Attack” cost millions of dollars simply because of 
naive bugs in the smart contract code. Blockchain and smart contract technologies have multiple aims, but unfortunately, new applications 
based on them still contain bugs and multiple vulnerabilities, which cause 
several issues for the end-users. Most of the use of this technology relates to finance or certifications, therefore integrity, 
authentication and authorisation in transactions are mandatory. 

The research field behind blockchain technology is growing, as well as the one concerning 
its security and accordingly, many analysis tools were developed. 
These incorporate various strategies for performing the analyses, concerning the technical aspects of smart contracts, 
so these would work differently according to the object of the analysis. 

Among the many aspects of smart contract, our systematic
literature review focuses on studies related to vulnerabilities and 
analysis tools for their detection. We will try to give an answer to the following 
research questions:
\begin{itemize}
    \item Which are the main vulnerabilities in Smart Contracts?
    \item Which methodologies are implemented by analysis tools?
    \item How should we behave for the detection of Vulnerabilities?
\end{itemize}

In Section \ref{RelatedWorks}, we compare the actual papers and works regarding this topic. 
Section \ref{Vulnerabilities} explains the objective of our analysis: Smart Contracts Vulnerabilities. 
We give a taxonomy for the main vulnerabilities regarding Solidity. The classification of analysis tools 
is shown in Section \ref{Tools}. We discuss about the main strategies implemented by those.
Options
\begin{itemize}
  \item In the last Section \ref{Conclusion} we try to define a guideline for detecting vulnerabilities. 
  \item In the last Section \ref{Conclusion} we give an overview, defining the suitable cases which 
the tools work better.
  \item In the last section \ref{Conclusion} we propose a real case.
\end{itemize}


\section{Releted Works}
\label{RelatedWorks}
\begin{itemize}
  \item Papers about vulenrabilities detection for defing a taxonomy
  \item papers regarding comperison between tools
  \item papers of the tools that we want to have a Look
\end{itemize}

\citet{SystematicReviewVuln} 

\section{Vulnerabilities in Solidity}
\label{Vulnerabilities}
An overview of classification of Vulnerabilities in Solidity is given in this section. 
Classifications by scholars and community taxonomies are the strating point for drowing our own classification. 
These knoledges are used for having our own classification; we depicted which ones are the most relevant 
vulnerabilities for our work.
The term vulnerability is used in a similar sense than is common in computer security. 
It refers to a weakness or limitation of a smart contract that may result in
security problems. 
A vulnerability represents even the way the attacker can exploit the contract. 
This includes locked or stolen resources, breaches of confidentiality or data integrity, and state
changes in the environment of smart contracts that were not
detected by developers or users, therefor they possibly be exploited by a malicious part.

\subsection{Vulnerabilities Classification and examples}
\label{sec:Vulnerabilities:Classification}
We summeries 8 different Vulnerabilities, providing a definition and a real-world example.

\paragraph{Reentrancy} It is one of the vulnerabilities much more exploited during the recent year. 
Many attacks occured and could steal great amount of many to vulnerable protocol. 
A reentrancy attack can occur when a function makes an external call to another untrusted contract 
before it resolves any effects. 
A recursive call back to the original function is made by the attacker, before 
the function could updated the state of the state of the variables. 
The goal is repeating interactions that would have otherwise not run after the effects were resolved. 
The function withdraw, line 8 to 16 \autoref{lst:Reentrancy}, implements this bug, because the balance of the user is updated after the external call. 
The attacker, with the usage of a malicious smart contract, can call again the vulnerable function. 
It is run multiple time, without updating the balance, withrawing all the funds. There are several countermeasures for this type of bug: 
semaphores logic can be implemented with the modifiers, the update of the variable can be moved before the external call. 
The external call can be safe if the developer checks the amount of gas used, in order to avoid an attacker can modify the control flow. 
\begin{lstlisting} [language=Solidity, caption={Reentrancy}, label={lst:Reentrancy}]
contract EtherStore {
    mapping(address => uint) public balances;
    ...
    //vulnerable function exploited by the attacker
    function withdraw() public {
        uint bal = balances[msg.sender];
        require(bal > 0);

        (bool sent, ) = msg.sender.call{value: bal}("");
        require(sent, "Failed to send Ether");

        balances[msg.sender] = 0;
    }
    ...
}
  
\end{lstlisting}

\paragraph{Unexpected Ether balance} An exploites can generated a Dos attack when the smart contract strictly assume a specific token balance. 
It is always possible to forcibly send ether to a contract (without triggering its fallback function), 
using selfdestruct, or by mining to the account. Smart Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is sent.
In the provided example (\autoref{lst:UnexpectedEther}), the function play() has a require at line 5, which checks no players can play when the balance 
reaches the predefined threshold. The function claimReward(), allows the user to withdraw, when the balance reaches the threshold. 
An attacker can send ether to this contract, for manipulating its balance. If it was greater than the threshold, the functions would always 
revert because of the require. As a consequence, no one could withdraw the funds and call the function play().
\begin{lstlisting} [language=Solidity, caption={Unexpected Ether}, label={lst:UnexpectedEther}]
  ...
  function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
  }
  function claimReward() public {
    // ensure the game is complete
    require(this.balance == finalMileStone);
    // ensure there is a reward to give
    require(redeemableEther[msg.sender] > 0); 
    redeemableEther[msg.sender] = 0;
    msg.sender.transfer(redeemableEther[msg.sender]);
  }
  ...
\end{lstlisting}

\paragraph{Overflows \& Underflows} The Ethereum Virtual Machine (EVM) defineds fixed-size data types for integers. 
An example is the identifier uint8, unsign integer over 8 bit, for variables means the variable can only store numbers in the range [0,255].
The attacker can craft the input value of a vulnerable contract's function in order to force a specific operation. 
In the contract TimeLock in \autoref{lst:ArithmeticOp}, an attacker could forge a parameter of the function function increaseLockTime, 
in oder to set lockTime to 0 because of Overflows. So it can call withraw and passing the require at line 17.
The most common way for solving these issues is to build or use mathematical libraries which replace the standard math operators. 
\href{https://www.openzeppelin.com/}{OppenZepplin} is a company, dealing with Blockchain technologies. It has done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community.
SafeMath library can be found in most of the deployed smart contracts.
\begin{lstlisting}[language=Solidity,caption={Overflows \& Underflows},label={lst:ArithmeticOp}]
contract TimeLock {
  
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }
    
    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
    
    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
}
\end{lstlisting}

\paragraph{Block Timestamp Manipulation} ispart of the cathegory of vulnerabilities that can be exploited by corrupt miners. 
A miner cac forge the timestamp by a few seconds, for obtaing benefits. 
The timestamp dependence vulnerability occurs from a flawed comprehension of timekeeping. It enables the Ethereum
network to be detached from the synchronized global clock. 
The block timestamp can be used as entropy for random numbers, locking funds for periods of time and various state-changing 
conditional statements that are time-dependent. Since the smart contract permits miners to put up a
timestamp within 30 seconds of block validation, this gives a miner more opportunity for exploitation.
\autoref{lst:BlockTimeStamp} shows a function (a fallback) which implements the logic of a lottery. The users can send ether to this contract, which 
accepts just one transaction per block. If the block is a multiple of 15, the user receives all the funds. This function is based on the timestamp of the balck, 
a malicious miner could adjust the timestamp for getting the win.
\begin{lstlisting}[language=Solidity,caption={Block Timestamp},label={lst:BlockTimeStamp}]
  ...  
  // fallback function used to make a bet
  function () public payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(now != pastBlockTime); // only 1 transaction per block
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
  }
  ...
\end{lstlisting}

\paragraph{Call to the unknown} The smart contracts workflow might be manipulated by 
the invocation of third party or untrusted code. The callee can implemnt malicous code which can be run and 
modify the normal execution of the calleer. For an untrusted, malicious
party, it might be possible to inject code in a way, that can inﬂuence the contracts behavior unexpectedly
and maliciously. A common case is the reentrancy, which can involve the Solidity functions .call(), .send() and .transfer(). 
Mistyped direct function calls or using the wrong function signature are classified as this type of vulnerability. 
The contract CallerContract in \autoref{lst:CallToUnknown} is an example of this vulnerability. An attacker could call the function caller, passing 
as parameter the address of a malicious contract, which implement a malicious fallback. In that case the fallback would be triggered, bacause the contract 
does not have any function with that name.

\begin{lstlisting}[language=Solidity,caption={Call to the unknown},label={lst:CallToUnknown}]
cotract CalleeCotract{ 
  fucntion toBeCalled(){
    //do some operations
  }
}

contract CallerContract{
  functionn caller(address a){
    toBeCalled(a).toBeCalled();
  }
}

contract Malicious{
  fallback(){
    //the attack
  }
}
\end{lstlisting}

\paragraph{Transaction Ordering Dependence} Miners are responsable for the creation and certification of 
the blocks on the blockchain. Inside those, the transactions are stores, but their order is not guaranteed by 
design and the miners can easily manipulate that. Consequently, this makes the smart contracts vulnerable to the transaction
order dependency, it can be classified as a type of race condition. The vulenrability relies on smart contracs critical decision 
are based on the order of transaction. Moreover, if two dependent transactions are invoked by the same contract then ordering of transactions must affect the states of blockchain. 
So we can have a case of race condition, even with a miner without malicious aims.

The smart contract MarketPlace(\autoref{lst:TOD}) implements the logic of a market place. The users can buy an arbitrary amount of stock and the 
owner can set the price. In this case the variable price is influenced by two functions. If the owner of the contract would be a miner, it could 
manipulate the order of transaction. The miner-seller can inﬂuence the transaction orders and update the price after the buy request was 
sent, but before it is processed, eﬀectively increasing the anticipated price for the buyer. The seller can just modify the price, while a user is buying and it can effect its action.

\begin{lstlisting}[language=Solidity,caption={Transaction Ordering Dependence},label={lst:TOD}]
contract MarketPlace {
  uint256 price;
  uint256 stock;
  address owner;
  constructor() {
    owner= msg.sender;

  }
  modifier onlyOwner(){
    require(msg.sender==owner);
    _;
  }
  function updatePrice(uint256) onlyOwner {

  }
  function buy(uint256 amount){
    require(stock>=amount);
    require (msg.value >=amount*price);
    stock-=quant;
  }
}
\end{lstlisting}

\paragraph{Denial Of Service (DOS)} Denial of service attack is a cathegory of attack, which involeves all those one which have the aim to 
disturb the functionality or stop the execution of the target system. In the context of smart contracts, we can provide some example of this cathegory, 
which involve multiple strategies for breaking the normal flow execution of the program.

\autoref{lst:DOS} shows a simpliefied contract for auction. The function refundUsers() has the responsibility to refund all the bidder. 
The function contains a loop, so it can get the amount of the bid of the user and refund it. The bug relies on the the require inside the loop. If the transaction returns false, 
the require fails, so all the transactions are reverted, consequently all the previous refunds are reverted. A malicious contract can be implemented for taking part to the function, but 
that one reverts every time it receives ether. In this way, the function refundUsers() would always revert and no users can be refunded.

\begin{lstlisting}[language=Solidity,caption={Denial of Service/Out of Gas},label={lst:DOS}]
contract Auction {
  mapping (address=>uint256) allBids;
  mapping (uint256=>address) users;
  uint256 nUsers;
  uint256 lastrefund;
  ... 
  function refundUsers() {
    
    for(uint256 i = lastrefund; i<nUsers;i++){
      address user=users[i];
      uint256 amount= allBids[user];
      (bool sent, )= user.call{value: amount}("");
      require(sent);
    }

  }
  ... 
}
\end{lstlisting}


\paragraph{Out of Gas} In Ethereum, we have to pay for each computational operation, measured in the unit called gas. 
In the Ethereum documentation, gas is defined as follows: “Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the Ethereum network. 
Since each Ethereum transaction requires computational resources to execute, each transaction requires a fee. 
Gas refers to the fee required to conduct a transaction on Ethereum successfully.” 

The sender pays the transaction fee, previously specifying the gas limit, If the payed amount exceeds the fee, it will receive a refund when the transaction finishes. 
If the actual execution cost of the transaction exceeds the gas limit, the transaction will fail with an out of gas error. 
We used \autoref{lst:DOS} for showing an example of DOS, but it implements an out of gas vulnerability too. 
The amount of gas depends on the number of the for loop's iteration. If the number of iteration grows too much, the function would always revert. A malicious attacker can 
manipulate the number of iterations, using a great number of wallet for the bid.

\paragraph{Unchecked CALL/SEND Return Values} There a number of ways of performing external calls in solidity. The transfer() method is the most common way for exchanging ether between smart contracts. 
It reverts if the something goes wrong and function does not succeed. However, the send() and call() function can also be used and, for more versatile external call. 
These functions return a boolean indicating if the call succeeded or failed.  A common bug relies on the return value is not checked, rather the developer expects a revert to occur. 

The user can call the function withdrawEmergency()  at line 4, \autoref{lst:UncheckedReturn}, for withdrawing all its funds. The function updates the value of the mapping balances, setting 
the balance of the user to zero. If the function does not succeed, it does not revert. 
The funds of the user would be stacked insed the contract. Moreover the amount of ether in the contract is miscomputed.


\begin{lstlisting}[language=Solidity,caption={Unchecked CALL/SEND Return Values},label={lst:UncheckedReturn}]
contract Bank{
  mapping (address=> uint256) balances;
  ... 
  function withdrawEmergency() public {
    require(balances[msg.sender] > 0);
    uint256 amount= balances[msg.sender];
    balances[msg.sender] = 0;
    etherLeft -= _amount;
    msg.sender.send(amount);
  }
  ...
}

\end{lstlisting}

\section{Methods for finding Vulnerabilities}
\label{MethodologiesForTools}











\paragraph{Static analysis} refers to a class of methods that examine
the source code or bytecode of a contract without execut-
ing it. Most methods listed below are static.
\paragraph{Dynamic analysis} means to observe a contract while
executing (parts of) it in the original context.
\paragraph{Disassembling} means to translate EVM bytecode into bet-
ter readable assembly language, where machine operations
and storage addresses are represented symbolically.
\paragraph{Decompilation} is the process of transforming EVM byte-
code to a more compact representation on a higher abstrac-
tion level (like intermediate or Solidity code) to enhance
the readability of the code or to ease data ﬂow analysis.
\paragraph{Control ﬂow graph (CFG)} is a directed graph, where the
basic blocks of a program serve as the nodes. An arc
connects node A with node B if it is possible that block B
gets executed immediately after block A. The arc may be
labeled by the condition under which this path is chosen.
\paragraph{Formal veriﬁcation} means veriﬁcation by formal methods
with the aim of proving or disproving system properties
rigorously. As a prerequisite, all components referenced
by such a property as well as their behavior must have
been speciﬁed formally. E.g., to verify properties of smart
contracts on bytecode level formally, we need a formal
speciﬁcation of the EVM and of the properties.
\paragraph{Dynamic CFG} is similar to a CFG with the difference that
arcs indicate the actual control ﬂow encountered during a
particular execution of the code.
\paragraph{Model checking} is a technique for automatically verifying
correctness properties of ﬁnite-state systems. It requires a
model of the system which is then checked against a given
speciﬁcation.
\paragraph{Call graph} is a directed graph, where the nodes are
functions. There is an arc from node A to node B if
function A calls function B.
\paragraph{Abstract Syntax Tree (AST)}represents the syntactic struc-
ture of Solidity code as a tree. It occurs as an intermediate
product when compiling Solidity to bytecode. Often, it is
better suited for analyzing Solidity code.
\paragraph{Symbolic execution} means to execute code using symbols
instead of concrete values for the variables. Operations
on these symbols lead to algebraic terms, and conditional
statements give rise to propositional formulas that char-
acterize the branches. A particular part of the code is
reachable if the conjunction of formulas on the path to this
part is satisﬁable, which can be checked by SMT-solvers.

\section{Real-World Case}
\label{RealCase}

\section{Conclusion}
\label{Conclusion}


\begin{acks}

\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\section{Research Methods}

\subsection{Part One}


\end{document}
\endinput
%%
%% End of file `sample-sigconf-i13n.tex'.
