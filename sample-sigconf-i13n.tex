%%
%% This is file `sample-sigconf-i13n.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf-i13n')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf-i13n.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.

\documentclass[a4paper,sigconf, language=french,
language=german, language=spanish, language=english]{acmart}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{rightsretained}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{}

%% These commands are for a PROCEEDINGS abstract or paper.

\acmConference[Colloquium on Vulnerability Discovery 2022]{Colloquium on Vulnerability Discovery 2022}{August 1st, 2022}{KIT, Karlsruhe, Germany}
\acmPrice{00.00}
\acmISBN{}

\settopmatter{printacmref=false}

\settopmatter{printccs=false}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\input{solidity-highlighting.tex}	
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Finding Vulnerabilities in Smart Contracts}


%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Michele Massetti}
\email{big.michelemassetti@gmail.com}
\affiliation{%
  \institution{Karlsruhe Institute of Technologies}
  \city{Karlsruhe}
  \state{Baden-Württemberg}
  \country{Germany}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Massetti.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Blockchain is a revolutionary technology that enables users to communicate in a trust-less manner. 
The most prominent change brought by this technology is the mode of business between organizations: they do not need anymore a trusted third party. 
It is a distributed ledger technology based on a decentralized peer-to-peer (P2P) network. 
Since Bitcoin was deployed, many blockchain systems have been born with more capabilities, which have allowed them to fit many
different use cases. Smart Contracts, which are programs running on blockchain systems, could extend the potentiality of blockchain
from a platform for financial transactions to an all-purpose utility.
The development of innovative and prominent applications is a consequence of them, such as NFT marketplaces, music royalty tracking, supply chain and logistics monitoring, voting mechanisms, 
cross-border payments, and many others.
Finding bugs and vulnerabilities in them is necessary for assuring their correct behaviour. 
This paper deals with the way for finding the vulnerabilities in Ethereum based Smart Contracts. We review related work regarding 
the classification of the most common vulnerabilities and tools which support their detection.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Solidity, Software, Vulnerability, Blockchain}


%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
Nowadays, the major platform for decentralized ﬁnance (DeFi) 
and applications (dApps) is Ethereum. It can be described as the "internet of Blockchain".
Its ecosystem consists of the underlying blockchain, a large
variety of smart contracts deployed on it, a wide range of
valuable assets. 

This growing technology has fascinated many investors, indeed, according \href{https://www.coingecko.com/}{CoinGeko}, 
the crypto market's value is standing around \$2 trillion. 
On the other hand, interest in such a market has grown even among malicious attackers. 
Attacks such as the “Parity Wallet Hack” and the “Decentralized Autonomous Organization Attack” cost millions of dollars simply because of 
naive bugs in the smart contract code. Blockchain and smart contract technologies have multiple aims, but unfortunately, new applications 
based on them still contain bugs and multiple vulnerabilities, which cause 
several issues for the end-users. Most of the use of this technology relates to finance or certifications, therefore integrity, 
authentication and authorisation in transactions are mandatory. 

The research field behind blockchain technology is growing, as well as the one concerning 
its security and accordingly, many analysis tools were developed. 
These incorporate various strategies for performing the analyses, concerning the technical aspects of smart contracts, 
so these would work differently according to the object of the analysis. 

Among the many aspects of smart contract, our systematic
literature review focuses on studies related to vulnerabilities and 
analysis tools for their detection. We will try to give an answer to the following 
research questions:
\begin{itemize}
    \item Which are the main vulnerabilities in Smart Contracts?
    \item Which methodologies are implemented by analysis tools and which are the most used ones?
    \item Which are possible new approaches for discovering vulnerabilities?
\end{itemize}
Section \ref{Background} gives an overview of blockchain and smart contracts technology, the execution environment and model. 
In our work we focus on the Ethereum platform, however many concepts can be adapeted in multiple blockchain EVM (Ethereum Virtual Machine) compatible.

In Section \ref{RelatedWork}, we deal with the actual papers and work regarding this topic, citing the ones we studied for the writing of this paper.

Section \ref{Vulnerabilities} gives a taxonomy for the main vulnerabilities about Solidity. 

The classification of analysis tools is shown in Section \ref{MethodologiesForTools} and their strategies are described.

Section \ref{Discussion} is addressed to the new incoming methods for finding vulnerabilities.




\section{Related Work}
\label{RelatedWork}
Our work is addressed to define the most common vulnerabilities and the most used tools for finding those.
The first step was getting in touch with research works which deal with topics such as vulnerabilities and analysis tools. For a better comprehension of the matters, we collect information about the basis of blockchain technology and security terminology. \cite{ETHfoundation} provides an overview 
of Ethereum environment. 

We selected the analaysis tools strating from the reading of surveys and papers as \cite{SurvTools}, \cite{Thesis}, \cite{AutomaticTools}, \cite{AttacksAndProtection}, \cite{ToolsAndVuln}. 
Those deal with a great number of tools, defining their characteristics and those produce a comparison between tools based on selected benchmarks. We deepen our knowledge about the tools by reading their provided papers
(\cite{Slither} \cite{Echidna} \cite{Manticore} \cite{SmartTest} \cite{Oyente}). 

\cite{Methodologies} compare different strategies implemented by tools, citing even Machine Learning, which has been used in this matter just recently.
Since Machine Learning popularity has grown in the computer science, recent papers has proposed it as a technique in this field, for example \cite{FuzzML}, which tries to combine it with fuzzing, and \cite{MLSmartContractPropose}

We drew the definition of the vulnerabilities through the benchmark used by the papers, moreover, we based our selection on the two most used open-source databases for smart contract vulnerabilities, which are \cite{SWC} and \cite{DASP10}.

\section{Background}
\label{Background}
This section gives to the reader some basic knowledge about blockchain, focusing on Ethereum and its smart contracts. We briefly introduce its general structure and how security is applied in this context.
\subsection{Blockchain}
Blockchain is a shared ledger that holds transactions and information in a decentralised peer-to-peer network. A blockchain acts as a database, storing information in a digital format. 
This technology is best known for its vital role in cryptocurrency systems, such as Bitcoin, to maintain a secure and decentralized record of transactions. 
The innovation is that it ensures the truthfulness and security of data records and creates trust without the need for a trusted third party.

It acts like a database, however, it organises data into units called blocks, each of which contains a collection of data.
Blocks have specific storage capacities, and when they are full, they are closed and linked to the preceding block, producing a data chain known as the blockchain.
All additional information added after that newly added block is compiled into a new block, which is then added to the chain after it is filled.  

Each computer in the network must agree on each new block and the entire chain. 
These calculators are called "nodes". These ensure that everyone who interacts with the blockchain has the same data. 
New blocks are broadcasted to network nodes, which track and verify those, moreover, the state of the blockchain is updated for everyone.
To achieve this distributed agreement, blockchains need a consensus mechanism. 

The purpose is to allow digital information to be recorded and distributed, but not edited. 
In this way, an immutable ledger or record of transactions is generated, thus that cannot be modified, deleted, or destroyed. 
This is why blockchain is also known as Distributed Ledger Technology (DLT). 


\subsection{Ethereum Enviroment}

Ethereum is a blockchain-based global decentralised software platform. 
Anyone can use Ethereum to construct any secure digital technology they can imagine.
It has a token built for usage on the blockchain network, but it may also be used to pay for work done on the blockchain by participants. 
It is built to be decentralised, scalable, programmable, and secure. It is the blockchain of choice for developers and businesses who are building technologies on top of it to transform numerous sectors and our everyday lives.
It natively supports smart contracts, which are the essential tool behind decentralized applications. Regarding development and interaction, Ethereum is the leader in this sector. 

In the Ethereum universe, there is a single, canonical computer (known as the Ethereum Virtual Machine, or EVM) whose state everyone on the Ethereum network agrees on. 
Every Ethereum node (participant in the Ethereum network) saves a copy of this computer's current state. 
A participant can also broadcast a request for this computer to conduct any computation they choose. 
When a request like this is broadcast, other network members verify, validate, and carry out (or "execute") the computation. 
The EVM's state changes as a result of this execution, which is committed and propagated throughout the network. The consensus algorithm, which ensures the correct system's behaviour, is called "proof of works". 
It involves that anyone, who wishes to add additional bricks to the chain, must first solve a complex challenge that takes a lot of processing resources.
Solving the puzzle "proves" that you used computing resources to do the "job."
Mining is the process of doing so. It is usually done by trial and error, but adding a block earns you ETH. The nodes, which compute these types of operation, are called "miners".

Recently, Ethereum is moving off of POW, it is implementing "proof of stake" as a consensus algorithm. It has the consequence that the nodes are no anymore called miners but validators. These have to stake, and collect, at least 32 ETH on a smart contract on the chain. The nodes have the same role of validating the transaction, but in this way, computational and electrical energies are saved.

Transactions are cryptographically signed instructions from accounts, which are any entities which can collect the native token ETH. An account will initiate a transaction to update the state of the Ethereum network. 
The miners are responsible to collect the transaction, changing the state of the EVM and broadcasting those in the network. Transactions require a fee and must be mined to become valid. 
The unit of measurement for the amount of computing effort necessary to perform various activities on the Ethereum network is called gas. It represents the fuel of the blockchain. 
The account can set a limit on the amount of ETH to pay. If the price of gas is less than the one paid by the user, it has a refund. If the amount of fees is not enough, a "out of gas" exception can occur.



\subsection{Smart Contracts and Solidity}
The definition given by the Ethereum foundation of Smart concract is:

\textit{A "smart contract" is simply a program that runs on the Ethereum blockchain. It's a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.}

It is considered a type of Ethereum Account, which is any entity with an ether (ETH) balance that can send transactions on Ethereum. 
They are deployed on the network and run according to the code. User accounts can then engage with a smart contract by sending transactions that instruct the smart contract to perform a function. 
Smart contracts, like conventional contracts, can set rules and have them enforced automatically through programming.
They can't be deleted by default, and their interactions are permanent. 

The EVM smart contracts can be programmed in several languages. The most active and maintained language is Solidity, which our work deals with. 

It is an object-oriented and high-level language. It supports:
\begin{itemize}
  \item inheritance;
  \item libraries;
  \item complex user-defined types.
\end{itemize}

A smart contract, as a program developed in other programming languages, contains parameters, a constructor and functions. A peculiarity of this language is the fallback functions. 

They have been involved in many attacks, as will be explained in section \ref{Vulnerabilities}, but they were developed without a malicious aim. 
They are external functions with neither a name, parameters, or return values. Only one fallback can be assigned to a contract. 
A fallback function is triggered:
\begin{itemize}
  \item if a function identifier does not match any of the available functions in a smart contract;
  \item if there was no data supplied along with the function call.
\end{itemize}

A fallback function always receive data, but it should be marked as payable for accepting etheres. 


\subsection{Security of Smart Contracts}
Smart contracts are public and available by every account on the chain, but they can represent a drawback. In the security field, developers can implement some strategies by design for preventing malicious operations. For protecting software, a firewall can be implemented or even an IDS (intrusion detection system), the software can be achieved just by logging in to the VPN: more levels of security can be designed.
Those operate as a sort of filter, scanning the traffic, and applying the policy for accessing the program. 

On the other hand, none of those can be applied in smart contracts environment, so finding vulnerabilities is a big challenge for developers. 
Malicious accounts can exploit the bug inside the smart contract, but developers should be aware the order of the execution of transactions depends even on the miners which compute the blocks.

\begin{table*}
  \caption{Collection of Vulnerabilities}
  \label{tab:CollectionOfVulnerabilities}
  \begin{tabular}{ |p{5cm}|p{5cm}|p{5cm}| }
  \hline
  \multicolumn{3}{|c|}{Vulnerabilities} \\
  \hline
  Name  & DASP10 DB & SWC DB \\
  \hline
  Reentrancy  & DASP-1 & SWC-107 \\
  \hline
  Unexpected Ether balance  & & SWC-132  \\
  \hline
  Overflows \& Underflows  & DASP-3 & SWC-101 \\
  \hline
  Block Timestamp Manipulation  & DASP-8 & \\
  \hline
  Transaction Ordering Dependence  & DASP-7  & SWC-114 \\
  \hline
  Denial Of Service (DOS)  & DASP-5 &  SWC-113\\
  \hline
  Out of Gas  & DASP-5 & SWC-128 \\
  \hline
  Unchecked CALL/SEND Return Values  & DASP-4 & SWC-104\\
  \hline
  \end{tabular}
\end{table*}

\section{Vulnerabilities in Solidity}
\label{Vulnerabilities}
Related taxonomies by scholars and open-source projects are the starting point for drawing our classification of Vulnerabilities in Solidity. 
We selected the most recurrent vulnerabilities that we found during our research.
The term vulnerability is used in a similar sense than is common in computer security. 
It refers to a weakness or limitation of a smart contract that may result in
security problems. 
A vulnerability represents even the way the attacker can exploit the contract. 
This includes locked or stolen resources, breaches of confidentiality or data integrity, and state
changes in the environment of smart contracts that were not
detected by developers or users, therefore they possibly are exploited by a malicious part.

We summaries different vulnerabilities, providing a definition and \autoref{tab:CollectionOfVulnerabilities} shows the correlation with Dasp10 and SWC, associating per each vulnerability the identifier per project.

\subsection{Reentrancy} 
Reentrancy is one of the vulnerabilities much more exploited in recent years. 
Many attacks occurred and could steal a great amount of money from vulnerable protocols. 
A reentrancy attack can occur when a function makes an external call to another untrusted contract before it resolves any effects and the normal execution flow of the program is modified.
A recursive call back to the original function is made by the attacker, before 
the function could update the state of the variables. 
The goal is repeating interactions that would have otherwise not run after the effects were resolved. 
The function withdraws, lines 5 to 11 \autoref{lst:Reentrancy}, implements this bug, because the balance of the user is updated after the external call. 
The attacker, with the usage of a malicious smart contract, can call again the vulnerable function. 
It is run multiple times, without updating the balance, and withdrawing all the funds. There are several countermeasures for this type of bug: 
semaphores logic can be implemented with the modifiers, and the update of the variable can be moved before the external call. 
The external call can be safe if the developer checks the amount of gas used, to avoid an attacker can modify the control flow. 
One of the fundamental of this attack is the usage of fallback by the malicious contract, which is triggered every time it receives ETH.

\begin{lstlisting} [language=Solidity, caption={Reentrancy}, label={lst:Reentrancy}]
contract EtherStore {
    mapping(address => uint) public balances;
    ...
    //vulnerable function exploited by the attacker
    function withdraw() public {
        uint bal = balances[msg.sender];
        require(bal > 0);
        (bool sent, ) = msg.sender.call{value: bal}("");
        require(sent, "Failed to send Ether");
        balances[msg.sender] = 0;
    }
}

contract Attack {
    constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }

    // Fallback is called when EtherStore sends Ether to this contract.
    fallback() external payable {
        if (address(etherStore).balance >= 1 ether) {
            etherStore.withdraw();
        }
    }
    function attack() external payable {
        require(msg.value >= 1 ether);
        etherStore.deposit{value: 1 ether}();
        etherStore.withdraw();
    }

}
  
\end{lstlisting}

\subsection{Unexpected Ether balance} 
A smart contract of which logic relies on its balance can be exposed to unexpected receiving of ETH. 
A DOS attack can occur when the smart contract strictly assumes a specific token balance. 
In Solidity there is the fallback called "receive", which is a function triggered by the reception of ETH, so the developer can prevent a transaction could send ether. However, it is always possible to forcibly send ether to a contract (without triggering its fallback function), using "self-destruct", or by mining to the account. Smart Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is sent.
In the provided example (\autoref{lst:UnexpectedEther}), in the function play() line 5 there is a require, which checks no players can play when the balance 
reaches the predefined threshold. The function claimReward(), allows the user to withdraw when the balance reaches the threshold. 
An attacker can send ether to this contract, for manipulating its balance. If it was greater than the threshold, the functions would always 
revert because of the require. As a consequence, no one could withdraw the funds and call the function play().

\begin{lstlisting} [language=Solidity, caption={Unexpected Ether}, label={lst:UnexpectedEther}]
  ...
  function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
  }
  function claimReward() public {
    // ensure the game is complete
    require(this.balance == finalMileStone);
    // ensure there is a reward to give
    require(redeemableEther[msg.sender] > 0); 
    redeemableEther[msg.sender] = 0;
    msg.sender.transfer(redeemableEther[msg.sender]);
  }
  ...
\end{lstlisting}

\subsection{Overflows \& Underflows} 
The Ethereum Virtual Machine (EVM) defineds fixed-size data types for integers. 
An example is the identifier uint8, unsign integer over 8 bit, for variables means the variable can only store numbers in the range [0,255].
The attacker can craft the input value of a vulnerable contract's function in order to force a specific operation. 
In the contract TimeLock in \autoref{lst:ArithmeticOp}, an attacker could forge a parameter of the function function increaseLockTime, 
in oder to set lockTime to 0 because of Overflows. So it can call withraw and passing the require at line 17.
The most common way for solving these issues is to build or use mathematical libraries which replace the standard math operators. 
\href{https://www.openzeppelin.com/}{OppenZepplin} is a company, dealing with Blockchain technologies. It has done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community.
SafeMath library can be found in most of the deployed smart contracts. 

In Solidity version 0.8.0 arithmetic operations revert on underflow and overflow, consequently this vulnerability is avoided.
\begin{lstlisting}[language=Solidity,caption={Overflows \& Underflows},label={lst:ArithmeticOp}]
contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }
    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
}
\end{lstlisting}

\subsection{Block Timestamp Manipulation} 
Miners are responsible for collect validate the transaction, stored in blocks and deployed on-chain.
They can manipulate the timestamp of the block that they are managing and influence the execution of the transactions.

A miner can forge the timestamp by a few seconds, for obtaining benefits. 
The timestamp dependence vulnerability occurs from a flawed comprehension of timekeeping. It enables the Ethereum network to be detached from the synchronized global clock. 
The block timestamp can be used as entropy for random numbers, locking funds for periods of time and various state-changing 
conditional statements that are time-dependent. Since the smart contract permits miners to put up a
timestamp within 30 seconds of block validation, this gives a miner more opportunity for exploitation.
\autoref{lst:BlockTimeStamp} shows a function (a fallback) which implements the logic of a lottery. The users can send ether to this contract, which 
accepts just one transaction per block. If the block is a multiple of 15, the user receives all the funds. This function is based on the timestamp of the block, 
A malicious miner could adjust the timestamp for getting the win.
\begin{lstlisting}[language=Solidity,caption={Block Timestamp},label={lst:BlockTimeStamp}]
  ...  
  // fallback function used to make a bet
  function () public payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(now != pastBlockTime); // only 1 transaction per block
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
  }
  ...
\end{lstlisting}

\subsection{Transaction Ordering Dependence} 

Miners are responsible for the creation and certification of the blocks on the blockchain. 
Inside those, the transactions are stores, but their order is not guaranteed by 
design and the miners can easily manipulate that. Consequently, this makes smart contracts vulnerable to transaction
order dependency, which can be classified as a type of race condition. The vulnerability relies on smart contracts' critical decisions 
based on the order of transactions. Moreover, if two dependent transactions are invoked by the same contract then the ordering of transactions must affect the states of the blockchain. 
So we can have a case of race condition, even with a miner without malicious aims.

The smart contract MarketPlace (\autoref{lst:TOD}) implements the logic of a market place. The users can buy an arbitrary amount of stock and the 
owner can set the price. In this case, the variable price is influenced by two functions. If the owner of the contract would be a miner, it could 
manipulate the order of the transaction. The miner-seller can inﬂuence the transaction orders and update the price after the buy request was 
sent, but before it is processed, eﬀectively increasing the anticipated price for the buyer. The seller can just modify the price, while a user is buying and it can affect its action.

\begin{lstlisting}[language=Solidity,caption={Transaction Ordering Dependence},label={lst:TOD}]
contract MarketPlace {
  uint256 price;
  uint256 stock;
  address owner;
  constructor() {
    owner= msg.sender;
  }
  
  function updatePrice(uint256 amount) public {
    require(msg.sender==owner);
    ...
  }
  function buy(uint256 amount){
    require(stock>=amount);
    require (msg.value >=amount*price);
    stock-=quant;
  }
}
\end{lstlisting}

\subsection{Denial Of Service (DOS)} 
Denial of service attack is a category of attack, which involves all those that have the aim to 
disturb the functionality or stop the execution of the target system. In the context of smart contracts, we provide an example of this category, 
which involve multiple strategies for breaking the normal flow execution of the program.

\autoref{lst:DOS} shows a simplified contract for auction. The function refund users() has the responsibility to refund all the bidders. 
The function contains a loop, so it can get the amount of the bid of the user and refund it. The bug relies on the require inside the loop. If the transaction returns false, 
the require fails, so all the transactions are reverted, consequently, all the previous refunds are reverted. A malicious contract can be implemented for taking part in the function, but 
that one reverts every time it receives ether. In this way, the function refundUsers() would always revert and no users can be refunded.

\begin{lstlisting}[language=Solidity,caption={Denial of Service/Out of Gas},label={lst:DOS}]
contract Auction {
  mapping (address=>uint256) allBids;
  mapping (uint256=>address) users;
  uint256 nUsers;
  uint256 lastrefund;
  ... 
  function refundUsers() {
    
    for(uint256 i = lastrefund; i<nUsers;i++){
      address user=users[i];
      uint256 amount= allBids[user];
      (bool sent, )= user.call{value: amount}("");
      require(sent);
    }

  }
  ... 
}
\end{lstlisting}


\subsection{Out of Gas} 
In Ethereum, each computational operation requires a fee to be paid by the account which runs the transaction, measured in the unit called gas. 
In the Ethereum documentation, gas is defined as follows: “Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the Ethereum network. 
Since each Ethereum transaction requires computational resources to execute, each transaction requires a fee. 
Gas refers to the fee required to conduct a transaction on Ethereum successfully.” 

The sender pays the transaction fee, previously specifying the gas limit, If the paid amount exceeds the fee, it will receive a refund when the transaction finishes. 
If the actual execution cost of the transaction exceeds the gas limit, the transaction will fail with an out-of-gas error. 
We used \autoref{lst:DOS} for showing an example of DOS, but it implements an out-of-gas vulnerability too. 
The amount of gas depends on the number of the for loop's iteration. If the number of iterations grows too much, the function would always revert. A malicious attacker can 
manipulate the number of iterations, using a great number of wallets for the bid.

\subsection{Unchecked CALL/SEND Return Values} 
Solidity provides multiple ways for performing an external call. 
The transfer() method is the most common way of exchanging ether between smart contracts. 
It reverts if something goes wrong and the function does not succeed. However, the send() and call() functions can also be used and, for a more versatile external call. 
These functions return a boolean indicating if the call succeeded or failed.  A common bug relies on the return value is not checked, rather the developer expects a revert to occur. 

The user can call the function withdrawEmergency()  at line 4, \autoref{lst:UncheckedReturn}, for withdrawing all its funds. The function updates the value of the mapping balances, setting 
the balance of the user to zero. If the function does not succeed, it does not revert. 
The funds of the user would be stacked inside the contract. Moreover, the amount of ether in the contract is miscomputed.

\begin{lstlisting}[language=Solidity,caption={Unchecked CALL/SEND Return Values},label={lst:UncheckedReturn}]
contract Bank{
  mapping (address=> uint256) balances;
  ... 
  function withdrawEmergency() public {
    require(balances[msg.sender] > 0);
    uint256 amount= balances[msg.sender];
    balances[msg.sender] = 0;
    etherLeft -= _amount;
    msg.sender.send(amount);
  }
  ...
}

\end{lstlisting}

\section{Methods for finding Vulnerabilities}
\label{MethodologiesForTools}
This section is addressed to present the most effective and common tools with their strategies in Ethereum smart contracts context. 
We classify the tools in 2 main categories: with and without specification. The tables \ref{tab:ToolsWithoutSpec} and \ref{tab:ToolsWithSpec} collect the tools. 
In the first case, tools need specifications for running. On the other hand,  the former group 
deals with those which can give a result from the solidity file.
The last subsection deals with Machine Learning, which has been adopted in research and it is getting more effective.



\begin{table*}
  \caption{Tools without Specifications}
  \label{tab:ToolsWithoutSpec}
  \begin{tabular}{ |p{5cm}|p{5cm}|  }
  \hline
  \multicolumn{2}{|c|}{Tools Without Specifications } \\
  \hline
  Name & Keywords\\
  \hline
  Slither & Static Analysis Scanner\\
  \hline
  Mythril & Symbolic execution \\
  \hline
  SmartTest & Symbolic execution\\
  \hline
  Oyente  & Symbolic execution \\
  \hline
 \end{tabular}
\end{table*}
 

\subsection{Slither} Slither is a smart contract code static analysis framework.
It has rapid and reliable security detection algorithms for potential bugs.
Slither can be used for automatic vulnerability identification, automated optimization detection, code interpretation, and assisted code review, among other things.
For the security analysis, a multi-stage approach is started.
From the contract source code, the Solidity compiler generates a Solidity Abstract Syntax Tree (AST), which is utilised as an input to Slither.
Slither gathers important contract information such as the inheritance graph, Control-flow graph (CFG), and so on during the early stage.
The next stage includes converting the complete code to SlithIR.
The code analysis task is then completed by computing a list of pre-defined analyses in the next stage. 

\subsection{Mythril} 
Mythril is a security tool that examines Solidity-based smart contracts.
In order to discover code flaws, Mythril, an open-source programme, employs the symbolic execution technique.
Executing smart contract bytecode in a custom constructed EVM is used to look for security issues.
To complete its security study, Mythril goes through four major stages.
When a programme defect is detected, the input transactions are examined to establish the cause.
This security strategy aids in determining the root cause of a program's vulnerability as well as mitigating exploitation.
Mythril can discover problems in a contract's source code if a developer provides it. 

\subsection{SmartTest}
SmartTest is an Ethereum smart contract safety analyzer.
For effectively detecting susceptible transaction sequences, it uses a symbolic execution method.
The tool to detect transaction sequences, showing the weaknesses of the examined smart contract, is the project's core problem.
As a result, bugs are discovered as the source of multiple transaction interaction.
SmartTest's goal is to automatically deliver vulnerable transaction sequences that demonstrate the smart contract's flaws. 
The fundamental idea is to leverage known vulnerable transaction sequences to develop a statistical model that can be used to drive symbolic execution 
towards more successfully discovering unknown vulnerabilities.
Statistical language models direct symbolic execution, allowing it to select transacion sequences that are likely to reveal vulnerabilities.
The first step in this strategy is to perform unguided symbolic execution on existing vulnerable contracts, followed by learning a probability 
distribution over vulnerable transaction sequences. The detection of the following six types of security-critical vulnerabilities are supported
by the tool: integer over/underflow, assertion violation, division-by-zero, ERC20 standard
violation, Ether-leaking vulnerability (e.g., unauthorized access to transfer), and suicidal
vulnerability (e.g., unauthorized access to selfdestruct). In the paper, the authors focus on
just those, without considering vulnerabilities that require analysis of the interaction of
multiple contracts to demonstrate the flaws (e.g., reentrancy).

\subsection{Oyente}
Oyente is a symbolic execution tool for finding smart contract security flaws.
Oyente analyses Ethereum smart contracts for security flaws that could lead to possible attacks.
I does not only find dangerous bugs, but it also looks at every possible execution path.
In an experiment conducted by Oyente on 19,366 smart contracts, 8,833 of them were found to be susceptible.
The symbolic execution approach uses a mathematical formula to reflect the characteristics of an execution path.
Oyente compares the new formula to formulae that contain common bugs to see if both formulas are valid at the same time. 


\begin{table*}
  \caption{Tools With Specifications}
  \label{TollsWithSpec}
  \begin{tabular}{ |p{5cm}|p{5cm}|  }
    \hline
    \multicolumn{2}{|c|}{Tools With Specifications }\\
    \hline
    Name & Keywords \\
    \hline 
    Echidna  & Fuzzing, security properties and assertion analysis\\
    \hline
    Manticore  & Symbolic Execution, security properties analysis \\
    \hline
    SolcVerify & Formal Verification \\
    \hline
  \end{tabular}
\end{table*}
\subsection{Echidna} 
Echidna, Slither and Manticore were developed by the same researchers.
It's a sophisticated fuzzer for EVM that finds problems in Solidity code.
To conduct deep analysis for defects, this tool just requires Solidity propositions and provides a simple user interface (UI) to simplify its results.
Echidna tries several combinations of inputs until it succeeds in breaking the given property.
Echidna has a few characteristics with Manticore, allowing it to function at the EVM level.
It can also be merged into continuous integration (CI) to detect code issues while development is ongoing. 

The 2 most effective modes of this tool are the property mode and the assertion mode. In the first case, the developer writes in the smart contract a function, called the prefix "echidna\_test". It has the keywords public, callable by anyone, and view, because it does not alternate the variables. The return value is a \text{boolean} and it represents the property which the tool tries to break, for example, a variable uint cannot be greater than 100. On the other hand, in assertion mode, the developer writes the properties to check using the "assert(condition)". In both cases, the sequence of the function call for breaking the property is given, if it is found.

Echidna cannot directly detect the risk of reentrancy, just if the attacker contract is provided.

\subsection{Manticore} 
Manticore is a Solidity audit tool that analyzes smart contracts symbolically.
Manti-key core's functions include tracing inputs that terminate a program, logging instruction-level implementation, and offering Python API access to its analysis engine.
It features a capability called dynamic symbolic execution that examines binaries and Ethereum smart contracts.
The Core Engine, Native Execution Modules, and Ethereum Execution Modules are the three main components of Manticore's architecture.
Secondary features include the Satisfiability Modulo Theories (SMT-LIB) module, Event System, and API. 

Manticore can be run as a verifier, which means the developer specifies properties in the contract and the tool tries to break those. It has a similar grammar to Echidna, but in this case, the function name prefix is "crytic\_test". Otherwise, Manticore implements scanner modules for solidity, so it can detect the risk of typical vulnerabilities, such as reentrancy.

\subsection{SolcVerify} 
SolcVerify is an Ethereum smart contract source-level verification tool.
It accepts Solidity smart contracts and uses modular programme analysis to discharge verification conditions.
Because it is built on top of the Solidity compiler, it can reason at the contract source code level.
Solc-verify can reason about high-level contract properties while reliably modelling low-level language semantics as a result of this.
It is a compiler extension for the Solidity language.
It receives a collection of Solidity contracts, including specification annotations, and discharges verification conditions using the Boogie verifier and SMT solvers.
It converts annotated contracts to Boogie Intermediate Verification Language (BIVL).
\subsection{Machine Learning}
The adoption of machine learning techniques in the field of smart contracts is a result of their growing popularity. To identify suicidal, prodigal, and greedy contracts, \cite{MLAnalysis} implemnts a long-short term memory (LSTM).
By classifying contracts that were discovered by MAIAN as vulnerable during training, they were able to improve the LSTM model's test accuracy. 

\cite{CNNML} deals with the training of a CNN (convolutional Neural Network) by converting a sizable amount of Ethereum bytecode into RGB colour coding,  trained a CNN model. The model now automatically analyses input bytecode to flag potential compiler errors. 


\section{Discussion}
\label{Discussion}

\section{Conclusion}
\label{Conclusion}


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}



\end{document}
\endinput
%%
%% End of file `sample-sigconf-i13n.tex'.
