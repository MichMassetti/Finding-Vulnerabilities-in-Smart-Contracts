%%
%% This is file `sample-sigconf-i13n.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf-i13n')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf-i13n.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.

\documentclass[a4paper,sigconf, language=french,
language=german, language=spanish, language=english]{acmart}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{rightsretained}
\copyrightyear{2022}
\acmYear{2022}
\acmDOI{}

%% These commands are for a PROCEEDINGS abstract or paper.

\acmConference[Colloquium on Vulnerability Discovery 2022]{Colloquium on Vulnerability Discovery 2022}{August 1st, 2022}{KIT, Karlsruhe, Germany}
\acmPrice{00.00}
\acmISBN{}

\settopmatter{printacmref=false}

\settopmatter{printccs=false}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source


\input{solidity-highlighting.tex}	
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Finding Vulnerabilities in Smart Contracts}


%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Michele Massetti}
\email{ucmjt@student.kit.edu}
\affiliation{%
  \institution{Karlsruhe Institute of Technologies}
  \city{Karlsruhe}
  \state{Baden-Württemberg}
  \country{Germany}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Massetti.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Blockchain is a revolutionary technology that enables users to communicate in a trustless manner. 
The most prominent change brought by this technology is the mode of business between organizations: they do not need anymore a trusted third party. 
It is a distributed ledger technology based on a decentralized P2P (peer-to-peer) network. 
Since Bitcoin was deployed, many blockchain systems have been born with more capabilities, which have allowed them to fit many
different use cases. Smart Contracts, which are programs running on blockchain systems, could extend its potentiality from a platform for financial transactions to an all-purpose utility.

The development of innovative and prominent applications is a consequence of them, such as NFTs (non fungible token) marketplaces, music royalty tracking, supply chain and logistics monitoring, voting mechanisms, 
cross-border payments, and many others.

Security plays a central role in use cases having the integrity of data and financial matters as fundamental. Finding bugs and vulnerabilities is necessary for assuring the correct behaviour. 
This paper deals with the discovery of the vulnerabilities in Ethereum-based Solidity smart contracts. We review related work regarding the classification of the most common vulnerabilities, tools and methodologies which support their detection.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Solidity, Software, Vulnerability, Blockchain}


%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
Ethereum is the first blockchain which introduced the usage of smart contracts. Moreover, it can be described as the "internet of Blockchain", because it allows other systems to be built on top of itself, adopting its technology.

This growing technology has fascinated many investors, indeed, according to CoinGeko (\cite{Coin}), 
the crypto market's value is standing around \$2 trillion. 
On the other hand, interest in such a market has grown even among malicious attackers. 
Attacks such as the “Parity Wallet Hack” and the “Decentralized Autonomous Organization Attack” cost millions of dollars simply because of 
naive bugs in the smart contract code. Blockchain and smart contract technologies have multiple aims, but unfortunately, new applications 
based on them still contain bugs and multiple vulnerabilities, which cause 
several issues for the end-users. Most of the use of this technology relates to finance or certifications, therefore integrity, 
authentication and authorisation in transactions are mandatory. 

The research field behind blockchain technology is growing, as well as the one concerning 
its security and accordingly, many analysis tools were developed. 
These incorporate various strategies for performing the analyses, concerning the technical aspects of smart contracts, 
so these would work differently according to the object of the analysis. 

Among the many aspects of smart contract, our systematic
literature review focuses on studies dealing with vulnerabilities and methodologies, and the tools which implement those ones, for their detection. We will try to give an answer to the following 
research questions:
\begin{itemize}
    \item Which are the main vulnerabilities in Smart Contracts?
    \item Which analysis tools and which strategies are adopted for finding vulnerabilities?
    \item Which are possible new approaches for discovering vulnerabilities?
\end{itemize}


In Section \ref{RelatedWork}, we deal with the actual papers and studies regarding this topic, citing the ones we reviewed for the writing of this paper.

Section \ref{Background} gives an overview of blockchain and smart contracts technology, the execution environment and model. 

Section \ref{Vulnerabilities} gives a taxonomy for the main vulnerabilities about Solidity. 

We present the analysis tools we selected in Section \ref{MethodologiesForTools}, explaining their methodologies. Moreover, it deals with two more strategies implemented for the same aim: Machine Learning and testing deployed contracts.

Section \ref{Discussion} is addressed to a comparison between the discussed methodologies and 
possible strategies for the prevention of exploits.



\section{Related Work}
\label{RelatedWork}
Our work is addressed to define the most common vulnerabilities and the most used tools for finding those.
The first step was getting in touch with research works which deal with topics such as vulnerabilities and analysis tools. For a better comprehension of the matters, we collect information about the basis of blockchain technology and security terminology. 

We selected the analaysis tools starting from the reading of surveys and papers as the ones of \citet{SurvTools}, \citet{Thesis}, \citet{AutomaticTools}, \citet{AttacksAndProtection} and \cite{ToolsAndVuln}. 
Those deal with a great number of tools, defining their characteristics and those produce a comparison between tools based on selected benchmarks. We deepen our knowledge about the tools by reading their provided papers or online documentation.

\citet{Methodologies} in their paper, compare different strategies implemented by tools, citing even Machine Learning, which has been used in this matter just recently.
Since Machine Learning popularity has grown in the computer science, recent papers has proposed it as a technique in this field. 

We drew the definition of the vulnerabilities through the benchmark used by the papers, moreover, we based our selection on the two most used open-source databases for smart contract vulnerabilities, which are "Smart Contract Weakness Classification and Test Cases" (SWC) \cite{SWC} and "Decentralized Application Security Project" (DASP) Top 10  \cite{DASP10}. The former is a website, which is updated by the community containing the most common solidity vulnerability. It shows the vulnerabilities, defining an identifier (ID) and a list of related code samples. The latter is an open and collaborative project run by a private company, the NCC group. It presents ten different Solidity vulnerabilities, considered as the most relevant by the authors. Each one is presented with a brief description and a code example.

\section{Background}
\label{Background}
This section gives the reader the basics of blockchain, 
focusing on Ethereum and its smart contracts. We briefly introduce its general 
structure and how security is applied in this context.

The sources of our description of blockchain involve the general overview of this topic shown by the Ethereum Foundation (\cite{ETHfoundation}), 
the article written by \cite{BcArticle} and, our academic and work experiences.

We provide an overview of the Ethereum environment by 
collecting the information from the official 
documentation 
on the Ethereum Foundation (\cite{ETHfoundation}) and the presentation paper written by \citet{Ethereum}.
The definition of smart contract is embedded in those works, 
but for a deepen view we considered as well the article written by \citet{ScArticle}.

\subsection{Blockchain}
Blockchain is a shared ledger that holds transactions and information in a decentralised peer-to-peer network. This acts as a database, storing information in a digital format. 
This technology is best known for its vital role in cryptocurrency systems, such as Bitcoin, to maintain a secure and decentralized record of transactions. 
The innovation is that it ensures the truthfulness and security of data records and creates trust without the need for a trusted third party.

It acts like a database, however, it organises data into units called blocks, each containing a collection of data.
Blocks have specific storage capacities, and when they are full, they are closed and linked to the preceding block, producing a data chain known as the blockchain.
All additional information added after that newly added block is compiled into a new block, which is then added to the chain after it is filled.  

Each computer in the network must agree on each new block and the entire chain. 
These calculators are called "nodes". These ensure that everyone who interacts with the blockchain has the same data. 
New blocks are broadcasted to network nodes, which track and verify those, moreover, the state of the blockchain is updated for everyone.
To achieve this distributed agreement, blockchains need a consensus mechanism. 

The purpose is to allow digital information to be recorded and distributed, but not edited. 
In this way, an immutable ledger or record of transactions is generated, thus that cannot be modified, deleted, or destroyed. 


\subsection{Ethereum Environment}

Ethereum is a blockchain-based global decentralised software platform. 
Anyone can use Ethereum to construct any secure digital technology they can imagine.
It has a token built for usage on the blockchain network, but it may also be used to pay for work done on the blockchain by participants. 
It is built to be decentralised, scalable, programmable, and secure. It is the blockchain of choice for developers and businesses who are building technologies on top of it to transform numerous sectors and our everyday lives.
It natively supports smart contracts, which are the essential tool behind decentralized applications. Regarding development and interaction, Ethereum is the leader in this sector. 

In the Ethereum universe, there is a single, canonical computer (known as the Ethereum Virtual Machine, or EVM) whose state everyone on the Ethereum network agrees on.
Every Ethereum node (participant in the Ethereum network) saves a copy of this computer's current state. 
A participant can also broadcast a request for this computer to conduct any computation they choose. 
When a request like this is broadcast, other network members verify, validate, and carry out (or "execute") the computation. 
The EVM's state changes as a result of this execution, which is committed and propagated throughout the network. The consensus algorithm, which ensures the correct system's behaviour, is called "proof of work" (POW). 
It involves that anyone, who wishes to add additional bricks to the chain, must first solve a complex challenge that takes a lot of processing resources.
Solving the puzzle "proves" that you used computing resources to do the "job."
Mining is the process of doing so. It is usually done by trial and error, but adding a block earns you Ethereum native token (ETH or ether) as rewards. The nodes, which compute these types of operation, are called "miners".

Recently, Ethereum is moving off of POW, it is implementing "proof of stake" (POS) as a consensus algorithm. It has the consequence that the nodes are no anymore called miners but validators. These have to stake, and collect, at least 32 ETH on a smart contract on the chain. The nodes have the same role of validating the transaction, but in this way, computational and electrical energies are saved.

Transactions are cryptographically signed instructions from accounts, which are any entities which can collect the native token. An account will initiate a transaction to update the state of the Ethereum network. 
The miners are responsible to collect the transaction, changing the state of the EVM and broadcasting those in the network. Transactions require a fee and must be mined to become valid. 
The unit of measurement for the amount of computing effort necessary to perform various activities on the Ethereum network is called gas. It represents the fuel of the blockchain. 
The account can set a limit on the amount of ETH to pay. If the price of gas is less than the one paid by the user, it has a refund. If the amount of fees is not enough, a "out of gas" exception can occur.



\subsection{Smart Contracts and Solidity}
The definition given by the Ethereum foundation of Smart concract is:

\textit{A "smart contract" is simply a program that runs on the Ethereum blockchain. It's a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.}

It is considered a type of account, which is any entity with an ether balance that can send transactions on Ethereum. 
They are deployed on the network and run according to the code. User accounts can then engage with a smart contract by sending transactions that instruct the smart contract to perform a function. 
Smart contracts, like conventional contracts, can set rules and have them enforced automatically through programming.

They can't be deleted by default, and their interactions are permanent. 

The EVM compatible smart contracts, the ones which can run on the Ethereum Virtual Machine, can be programmed in multiple languages defined by Ethereum Foundation. The most active and maintained language is Solidity, which our work deals with. 

It is an object-oriented and high-level language. It supports:
\begin{itemize}
  \item inheritance;
  \item libraries;
  \item complex user-defined types.
\end{itemize}

A smart contract, as a program developed in other programming languages, contains parameters, a constructor and functions.

\subsection{Security of Smart Contracts}
Smart contracts are public and available by every account on the chain, but they can represent a drawback. In the security field, developers can implement some strategies by design for preventing malicious operations. For protecting software, multiple layers of secuirty can be implemented: a firewall can be deployed or even an IDS (intrusion detection system), the software can be achieved just by logging in to the VPN (virtual private network) scanning all the traffic.

On the other hand, none of those can be applied in smart contracts environment, so finding vulnerabilities is a big challenge for developers. 
Malicious accounts can exploit the bug inside the smart contract, but developers should be aware the order of the execution of transactions depends even on the miners which compute the blocks.


\begin{table*}
  \caption{Collection of Vulnerabilities}
  \label{tab:CollectionOfVulnerabilities}
  \begin{tabular}{ccl}
    \toprule
    Name  & DASP10 DB & SWC DB \\
    \midrule
    Reentrancy  & DASP-1 & SWC-107\\
    Unexpected Ether balance  & & SWC-132  \\
    Overflows \& Underflows  & DASP-3 & SWC-101\\
    Block Timestamp Manipulation  & DASP-8 & \\
    Transaction Ordering Dependence  & DASP-7  & SWC-114 \\
    Denial Of Service (DOS)  & DASP-5 &  SWC-113\\
    Out of Gas  & DASP-5 & SWC-128 \\
     Unchecked CALL/SEND Return Values  & DASP-4 & SWC-104\\
  \bottomrule
\end{tabular}
\end{table*}

\section{Vulnerabilities in Solidity}
\label{Vulnerabilities}
Related taxonomies by scholars and open-source projects are the starting point for drawing our classification of Vulnerabilities in Solidity. 
We selected the most recurrent vulnerabilities that we found during our research.
The term vulnerability is used in a similar sense than is common in computer security. 
It refers to a weakness or limitation of a smart contract that may result in
security problems. 
A vulnerability represents even the way the attacker can exploit the contract. 
This includes locked or stolen resources, breaches of confidentiality or data integrity, and state
changes in the environment of smart contracts that were not
detected by developers or users, therefore they possibly are exploited by a malicious part.

We summarise different vulnerabilities, providing a definition and \autoref{tab:CollectionOfVulnerabilities} shows the correlation with Dasp10 and SWC, associating each vulnerability with the identifier per project.

For forging this section, we collected information from the two open source databases SWC and Dasp10. Other sources from which we have drawn, 
are Solidity by Example \cite{SolidityExamples}, 
which has the aim to code examples to allow the users to improve their knowledge of Solidity, indeed it has a section reserved for the attacks. 

The article written by \citet{VulnMedium} was very useful for our work, because it presented sixteen vulnerabilities, providing each one with a code example, plus in some cases a real-world reference as well.

The section \autoref{RelatedWork} cites different papers which deal with vulnerabilities, our presentation is drawn from the collection of related work involved in our literature research. 

\subsection{Reentrancy} 
Reentrancy is one of the vulnerabilities much more exploited in recent years. 
Many attacks occurred and could steal a great amount of money from vulnerable protocols. 
A reentrancy attack can occur when a function makes an external call to another untrusted contract before it resolves any effects and the normal execution flow of the program is modified.
A recursive call back to the original function is made by the attacker, before 
the function could update the state of the variables. 
The goal is repeating interactions that would have otherwise not run after the effects were resolved. 

One of the fundamental of this attack is the usage of fallback by the malicious contract. 
They are functions with neither a name, parameters, or return values. Only one fallback can be assigned to a contract. 
A fallback function is triggered:
\begin{itemize}
  \item if a function identifier does not match any of the available functions in a smart contract;
  \item if there was no data supplied along with the function call.
\end{itemize}

A fallback function always receive data, but it should be marked as payable for accepting ETHs. 

The function withdraws, lines 5 to 11 \autoref{lst:Reentrancy}, implements this bug, because the balance of the user is updated after the external call. 
The attacker, with the usage of a malicious smart contract, can call again the vulnerable function, using a fallback function, triggered when the smart contract receives ETH. 

It is run multiple times, without updating the balance, and withdrawing all the funds. There are several countermeasures for this type of bug: 
semaphores logic can be implemented with the modifiers, and the update of the variable can be moved before the external call. 
The external call can be safe if the developer checks the amount of gas used, to avoid an attacker can modify the control flow. 


\begin{lstlisting} [language=Solidity, caption={Reentrancy}, label={lst:Reentrancy}]
contract EtherStore {
    mapping(address => uint) public balances;
    ...
    //vulnerable function exploited by the attacker
    function withdraw() public {
        uint bal = balances[msg.sender];
        require(bal > 0);
        (bool sent, ) = msg.sender.call{value: bal}("");
        require(sent, "Failed to send Ether");
        balances[msg.sender] = 0;
    }
}

contract Attack {
    constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }

    // Fallback is called when EtherStore sends Ether to this contract.
    fallback() external payable {
        if (address(etherStore).balance >= 1 ether) {
            etherStore.withdraw();
        }
    }
    function attack() external payable {
        require(msg.value >= 1 ether);
        etherStore.deposit{value: 1 ether}();
        etherStore.withdraw();
    }

}
  
\end{lstlisting}

\subsection{Unexpected Ether balance} 
A smart contract of which logic relies on its balance can be exposed to unexpected receiving of ETH.
A DOS attack can occur when the smart contract strictly assumes a specific token balance. 
In Solidity there is the fallback called "receive", which is a function triggered by the reception of ETH, so the developer can prevent a transaction could send ether. However, it is always possible to forcibly send ether to a contract (without triggering its fallback function), using "self-destruct", or by mining to the account. Smart Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is sent.
In the provided example (\autoref{lst:UnexpectedEther}), in the function play() line 5 there is a require, which checks no players can play when the balance 
reaches the predefined threshold. The function claimReward(), allows the user to withdraw when the balance reaches the threshold. 
An attacker can send ether to this contract, for manipulating its balance. If it was greater than the threshold, the functions would always 
revert because of the require. As a consequence, no one could withdraw the funds and call the function play().

\begin{lstlisting} [language=Solidity, caption={Unexpected Ether}, label={lst:UnexpectedEther}]
  ...
  function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
  }
  function claimReward() public {
    // ensure the game is complete
    require(this.balance == finalMileStone);
    // ensure there is a reward to give
    require(redeemableEther[msg.sender] > 0); 
    redeemableEther[msg.sender] = 0;
    msg.sender.transfer(redeemableEther[msg.sender]);
  }
  ...
\end{lstlisting}

\subsection{Overflows \& Underflows} 
The Ethereum Virtual Machine (EVM) defineds fixed-size data types for integers. 
An example is the identifier uint8, unsign integer over 8 bit, for variables means the variable can only store numbers in the range [0,255].
The attacker can craft the input value of a vulnerable contract's function in order to force a specific operation. 
In the contract TimeLock in \autoref{lst:ArithmeticOp}, an attacker could forge a parameter of the function function increaseLockTime, 
in oder to set lockTime to 0 because of Overflows. So it can call withraw and passing the require at line 17.
The most common way for solving these issues is to build or use mathematical libraries which replace the standard math operators. 

In Solidity version 0.8.0 arithmetic operations revert on underflow and overflow, consequently these vulnerabilities are avoided.

\begin{lstlisting}[language=Solidity,caption={Overflows \& Underflows},label={lst:ArithmeticOp}]
contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }
    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
}
\end{lstlisting}

\subsection{Block Timestamp Manipulation} 
Miners are responsible for collect validate the transaction, stored in blocks and deployed on-chain.
They can manipulate the timestamp of the block that they are managing and influence the execution of the transactions.

A miner can forge the timestamp by a few seconds, for obtaining benefits. 
The timestamp dependence vulnerability occurs from a flawed comprehension of timekeeping. It enables the Ethereum network to be detached from the synchronized global clock. 
The block timestamp can be used as entropy for random numbers, locking funds for periods of time and various state-changing 
conditional statements that are time-dependent. Since the smart contract permits miners to put up a
timestamp within 30 seconds of block validation, this gives a miner more opportunity for exploitation.
\autoref{lst:BlockTimeStamp} shows a function (a fallback) which implements the logic of a lottery. The users can send ether to this contract, which 
accepts just one transaction per block. If the block is a multiple of 15, the user receives all the funds. This function is based on the timestamp of the block, 
A malicious miner could adjust the timestamp for getting the win.
\begin{lstlisting}[language=Solidity,caption={Block Timestamp},label={lst:BlockTimeStamp}]
  ...  
  // fallback function used to make a bet
  function () public payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(now != pastBlockTime); // only 1 transaction per block
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
  }
  ...
\end{lstlisting}

\subsection{Transaction Ordering Dependence} 

Miners are responsible for the creation and certification of the blocks. 
Inside those, the transactions are stores, but their order is not guaranteed by 
design and the miners can easily manipulate that. Consequently, this makes smart contracts vulnerable to transaction
order dependency, which can be classified as a type of race condition. The vulnerability relies on smart contracts' critical decisions 
based on the order of transactions. Moreover, if two dependent transactions are invoked by the same contract then the ordering of transactions must affect the states of the blockchain. 
So we can have a case of race condition, even with a miner without malicious aims.

The smart contract MarketPlace (\autoref{lst:TOD}) implements the logic of a market place. The users can buy an arbitrary amount of stock and the 
owner can set the price. In this case, the variable price is influenced by two functions. If the owner of the contract would be a miner, it could 
manipulate the order of the transaction. The miner-seller can inﬂuence the transaction orders and update the price after the buy request was 
sent, but before it is processed, eﬀectively increasing the anticipated price for the buyer. The seller can just modify the price, while a user is buying and it can affect its action.

\begin{lstlisting}[language=Solidity,caption={Transaction Ordering Dependence},label={lst:TOD}]
contract MarketPlace {
  uint256 price;
  uint256 stock;
  address owner;
  constructor() {
    owner= msg.sender;
  }
  
  function updatePrice(uint256 amount) public {
    require(msg.sender==owner);
    ...
  }
  function buy(uint256 amount){
    require(stock>=amount);
    require (msg.value >=amount*price);
    stock-=quant;
  }
}
\end{lstlisting}

\subsection{Denial Of Service (DOS)} 
Denial of service attack is a category of attack, which involves all those that have the aim to 
disturb the functionality or stop the execution of the target system. In the context of smart contracts, we provide an example of this category, 
which involve multiple strategies for breaking the normal flow execution of the program.

\autoref{lst:DOS} shows a simplified contract for auction. The function refund users() has the responsibility to refund all the bidders. 
The function contains a loop, so it can get the amount of the bid of the user and refund it. The bug relies on the require inside the loop. If the transaction returns false, 
the require fails, so all the transactions are reverted, consequently, all the previous refunds are reverted. A malicious contract can be implemented for taking part in the function, but 
that one reverts every time it receives ether. In this way, the function refundUsers() would always revert and no users can be refunded.

\begin{lstlisting}[language=Solidity,caption={Denial of Service/Out of Gas},label={lst:DOS}]
contract Auction {
  mapping (address=>uint256) allBids;
  mapping (uint256=>address) users;
  uint256 nUsers;
  uint256 lastrefund;
  ... 
  function refundUsers() {
    
    for(uint256 i = lastrefund; i<nUsers;i++){
      address user=users[i];
      uint256 amount= allBids[user];
      (bool sent, )= user.call{value: amount}("");
      require(sent);
    }

  }
  ... 
}
\end{lstlisting}


\subsection{Out of Gas} 
In Ethereum, each computational operation requires a fee to be paid by the account which runs the transaction, measured in the unit called gas. 
In the Ethereum documentation, gas is defined as follows: “Gas refers to the unit that measures the amount of computational effort required to execute specific operations on the Ethereum network. 
Since each Ethereum transaction requires computational resources to execute, each transaction requires a fee. 
Gas refers to the fee required to conduct a transaction on Ethereum successfully.” 

The sender pays the transaction fee, previously specifying the gas limit, If the paid amount exceeds the fee, it will receive a refund when the transaction finishes. 
If the actual execution cost of the transaction exceeds the gas limit, the transaction will fail with an out-of-gas error. 
We used \autoref{lst:DOS} for showing an example of DOS, but it implements an out-of-gas vulnerability too. 
The amount of gas depends on the number of the for loop's iteration. If the number of iterations grows too much, the function would always revert. A malicious attacker can 
manipulate the number of iterations, using a great number of wallets for the bid.

\subsection{Unchecked CALL/SEND Return Values} 
Solidity provides multiple ways for performing an external call. 
The transfer() method is the most common way of exchanging ether between smart contracts. 
It reverts if something goes wrong and the function does not succeed. However, the send() and call() functions can also be used and, for a more versatile external call. 
These functions return a boolean indicating if the call succeeded or failed.  A common bug relies on the return value is not checked, rather the developer expects a revert to occur. 

The user can call the function withdrawEmergency()  at line 4, \autoref{lst:UncheckedReturn}, for withdrawing all its funds. The function updates the value of the mapping balances, setting 
the balance of the user to zero. If the function does not succeed, it does not revert. 
The funds of the user would be stacked inside the contract. Moreover, the amount of ether in the contract is miscomputed.

\begin{lstlisting}[language=Solidity,caption={Unchecked CALL/SEND Return Values},label={lst:UncheckedReturn}]
contract Bank{
  mapping (address=> uint256) balances;
  ... 
  function withdrawEmergency() public {
    require(balances[msg.sender] > 0);
    uint256 amount= balances[msg.sender];
    balances[msg.sender] = 0;
    etherLeft -= _amount;
    msg.sender.send(amount);
  }
  ...
}

\end{lstlisting}

\subsection{Vulnerable Logic}
The previous vulnerabilities specifically deal with problems involving Solidity. However, the smart contract, seen just as a 
program, could have a weak implementation.
The most frequent issue, though, is typically a simple mistake in the smart contract's logic.
These mistakes, which have a significant impact on security, can be the result of simple typographical errors or specification ambiguities. 

Decentralized finance (DeFi) is an emerging financial technology based on blockchain. Smart contracts usually implement the logic of a bank, providing financial operations. Since these collect a great amount of money, an error in their logic can cost millions of dollars. A leak of security can be caused by a bug dealing with the code itself (Solidity issue) or even by the logic of the program itself.  

Examples of bad logic implementation are the bugs concerning the pools, with leaks which allowed the attacker to drain the liquidity.
Liquidity pools, in the DeFi, are reserves of tokens secured in smart contracts. They are the primary technology underlying the present DeFi ecosystem. They allow user to deposit tokens receiving an interest on the deposit or provide lend. Bad implementation of the mechanism of reward or a miscalculation of the rewards can have the consequence of an exploit. 

A reason for an attack can rely even on the miscomputation of the algebraical formulas; it could bring to an exploit, even if the implementation in Solidity would be correct.


\section{Methods for Finding Vulnerabilities}
\label{MethodologiesForTools}
This section is addressed to present some analysis tools with their strategies for finding vulnerabilities in Solidity smart contracts. Moreover, we have a general overview of two different strategies.
We classify the tools in two main categories: with and without specification. 
We decided on this taxonomy based on the practical aspects of those. We wanted to underline which ones are "plug and play", so these can give a result starting from the solidity file, without any additional information. On the other hand, the other group requires custom specifications, for providing effective results.

Tables \ref{tab:ToolsWithoutSpec} and \ref{tab:ToolsWithSpec} collect the tools. 

The last subsections deal with general methodologies.
Machine Learning has been adopted in research and it is getting more effective. 

Checking the absence of bugs is fundamental, but even certifying the contract fulfils the prefixed goals is necessary. Thus, before deployment on the blockchain, there are strategies to control the behaviour of the contract, providing tests in a similar environment.

\subsection{Tools without specifications}
\label{ToolsWithouSpecifications}
\begin{table*}
  \caption{Tools without Specifications}
  \label{tab:ToolsWithoutSpec}
  \begin{tabular}{cc}
  \toprule
    Name & Keywords\\
    \midrule
    Slither & Static Analysis Scanner\\
    Mythril & Symbolic execution, Contract Bytecode \\
    SmarTest & Symbolic execution, Susceptible transaction sequences,\\
    Oyente  & Symbolic execution, Execution paths \\
    \bottomrule
 \end{tabular}
\end{table*}

In this subsection we present the list of tools without specification, providing for each of them a general overview of its methodology for finding vulnerabilities.

\paragraph{Slither} 
Slither is a smart contract code static analysis framework (\cite{Slither}).
It has security detection algorithms for potential bugs based developed i Python.
Slither can be used for automatic vulnerability identification, automated optimization detection, code interpretation, and assisted code review, among other things.
A multi-stage approach is the key point for the analysis.
From the contract source code, the Solidity compiler generates a Solidity Abstract Syntax Tree (AST), which represents the input source of the tool.

Slither uses that input for computing a list of pre-defined analyses. 

Its outcomes provide the label of the SWC database for defining the vullnerability.
\paragraph{Mythril} 
Mythril is an open-source security tool that examines Solidity-based smart contracts (\cite{Mythril}).
It employs the symbolic execution technique as methodology for the analysis.
The bytecode of the smart contract is generated and then is run in a custom EVM, for looking for security issues.
When a bug is detected, the input transactions are examined to establish the cause. 

This security strategy aids in determining the root cause of a program's vulnerability as well as mitigating exploitation.

Mythril accepts as input the source code of the contract, but even its bytecode. 

If the user provides the end point with the blockchain, it can analyse even contracts on-chain.

Its ouput provides the list of the transaction for triggering the bug and ,as well as Slither,  the label of the SWC database for defining the vullnerability.

\paragraph{SmarTest}
SmarTest is an Ethereum smart contract safety analyzer (\cite{SmarTest}).
To effectively detect susceptible transaction sequences, it uses a symbolic execution method.
The tool to detect transaction sequences, showing the weaknesses of the examined smart contract, is the project's core problem.
As a result, bugs are discovered as the source of multiple transaction interactions.
SmarTest's goal is to automatically deliver vulnerable transaction sequences that demonstrate the smart contract's flaws. 
The fundamental idea is to leverage known vulnerable transaction sequences to develop a statistical model that can be used to drive symbolic execution 
towards more successfully discovering unknown vulnerabilities.

Statistical language models direct symbolic execution, allowing it to select transaction sequences that are likely to reveal vulnerabilities.
The first step in this strategy is to perform unguided symbolic execution on existing vulnerable contracts, followed by learning a probability 
distribution over vulnerable transaction sequences. The detection of the following six types of security-critical vulnerabilities are supported
by the tool: integer over/underflow, assertion violation, division-by-zero, ERC20 standard
violation, Ether-leaking vulnerability (e.g., unauthorized access to transfer), and suicidal
vulnerability (e.g., unauthorized access to self-destruct). 

A limitation of this tool involves the lack of the detection of vulnerabilities that require analysis of the interaction of
multiple contracts to demonstrate the flaws: reentrancy is not covered.

\paragraph{Oyente}
Oyente is a symbolic execution tool for finding smart contract security flaws, written in Python (\cite{Oyente}). 
Regarding our literature research, this is one of the first tools for security analysis of Solidity smart contracts. 
Its first version was deployed in 2016.

It analyses Ethereum smart contracts for security flaws that could lead to possible attacks.
Dangerous bugs are not the only focus of this, but it also looks at every possible execution path, which can trigger an exploit.

The Solidity compiler is used for obtaining the bytecode, necessary for the analysis, and the disassembler displays opcodes in symbolic form.

The symbolic execution approach uses a mathematical formula to reflect the characteristics of an execution path.
Oyente compares the new formula to the ones that contain common bugs, so it can verify if both formulas are valid at the same time. 

The outcomes of the tool provide, if it is possible, a list of transactions for exploiting the discovered vulnerability.

\subsection{Tools with specifications}

The tools with specifications are listed in this subsection. We outline their main characteristics and briefly summarise their configurations.

\begin{table*}
  \caption{Tools With Specifications}
  \label{tab:ToolsWithSpec}
  \begin{tabular}{ccl}
    \toprule
    Name & Keywords \\
    \midrule
    Echidna  & Fuzzing, security properties and assertion analysis\\
    Manticore  & Symbolic Execution, security properties analysis \\
    SolcVerify & Formal Verification \\
    \hline
  \end{tabular}
\end{table*}


\paragraph{Echidna} 
Echidna, Slither and Manticore were developed by the same researchers.
It is a fuzzer for EVM that finds problems in Solidity code (\cite{Echidna}).
To conduct deep analysis for defects, this tool just requires Solidity propositions and provides a simple user interface (UI) to simplify its results.
Echidna tries several combinations of inputs until it succeeds in breaking the given property.
Echidna has a few characteristics with Manticore, allowing it to function at the EVM level.
It can also be merged into CI (continuous integration) to detect code issues while development is ongoing. 

The two most effective modes of this tool are the property mode and the assertion mode. In the first case, the developer writes in the smart contract a function, called the prefix "echidna\_test". It has the keywords public, callable by anyone, and view because it does not alternate the variables. The return value is a \text{boolean} and it represents the property which the tool tries to break, for example, a variable uint cannot be greater than 100. On the other hand, in assertion mode, the developer writes the properties to check using the "assert(condition)". In both cases, the sequence of the function call for breaking the property is given, if it is found.

Since it provides the list of function call of the contracts, a limitation of this tool is its impossibility to detect reentrancy issues, which involves external ones. It can cover those, just if the malicious contract is provided, so it recognises the sequence of function for the exploit.

\paragraph{Manticore} 
Manticore is a Solidity audit tool that analyzes smart contracts symbolically (\cite{Manticore}).
Manti-key core's functions include tracing inputs that terminate a program, logging instruction-level implementation, and offering Python API access to its analysis engine.
It features a capability called dynamic symbolic execution that examines binaries and Ethereum smart contracts.

Manticore can be run as a verifier (\cite{ManticoreVerifier}), which means the developer specifies properties in the contract and the tool tries to break those. It has a similar grammar to Echidna, but in this case, the function name prefix is "crytic\_test". Otherwise, Manticore implements scanner modules for solidity, so it can detect the risk of typical vulnerabilities, such as reentrancy.

\paragraph{SolcVerify} 
SolcVerify is an Ethereum smart contract source-level verification tool (\cite{SolcVerify}).
It accepts Solidity smart contracts and uses modular programme analysis to discharge verification conditions.
Because it is built on top of the Solidity compiler, it can reason at the contract source code level.
SolcVerify can reason about high-level contract properties while reliably modelling low-level language semantics as a result of this.
It receives a collection of Solidity contracts, including specification annotations, and discharges verification conditions using the Boogie verifier and Satisfiability modulo theories (SMT) solvers.
It converts annotated contracts to Boogie Intermediate Verification Language (BIVL). 
Its specification language is made by annotations. The user has to add the annotations to the smart contract, using the notations "///@notice ", for defining the specifications.
The output of this include does not cover the list of transactions for unproven the property, but it states if it could prove or unproven the specification.

\subsection{Machine Learning}
The adoption of machine learning (ML) techniques in the field of smart contracts is a result of their growing popularity. 

An example of adoption of this technique for detecting vulnerable smart contract is proposed by \citet{MLAnalysis}.
The authors introduce a long short-term memory (LSTM) model, which is a ML model involving a variant of recurrent networks mainly used to solve difficult sequential problems,with the aim of detecting smart
contract security threats at an opcode level. 
By classifying contracts that were discovered by MAIAN (\cite{MAIAN}) as vulnerable during training, they were able to improve the LSTM model's test accuracy. MAIAN is a tool which classifies the vulnerable contracts as:
\begin{itemize}
    \item suicidal:  smart contracts that can be killed by any arbitrary address; 
    \item prodigal: those which may lose funds to arbitrary addresses, which do not belong to the contract owner, or have not deposited Ether to the contract.
    \item greedy: those which cannot discharge Ether. 
\end{itemize} .

ContractWard (\cite{MLtool}) is an example of attempt of Automated Vulnerability Detection Models for Ethereum Smart Contracts. It can detect the following six types of vulnerability: 
\begin{itemize}
    \item integer Overflow;
    \item integer Underflow Vulnerabilities;
    \item transaction-Ordering Dependence (TOD);
    \item callstack depth attack vulnerability;
    \item timestamp dependency;
    \item reentrancy vulnerability.
\end{itemize}

The model adopts two simple classification algorithms, namely, Support vector machine (SVM) and K-nearest neighbours (KNN) together with two sampling methods.
The source codes of the smart contracts selected as datasets are transformed into operation codes (opcodes). Oyente, an analysis tool summarized in a paragraph in the subsection \autoref{ToolsWithouSpecifications}, has the role to scan the contracts and define their labels, which are six per each. Those are used to label the test set, for training the ML model.  N-Gram, which refers to n words that appear
continuously in text, is the algorithm implied for feature extraction.
One vs. Rest (OvR) algorithm is adopted for multi-label classification where
C1, C2, C3, C4, C5 and C6 correspond to the six selected vulnerabilities. 
Finally, detection models are built based on the balanced
training sets for the detection.

\subsection{Testing Smart Contracts On-Chain}
The purpose of the analysis tools is to assure that there are no bugs. Some of them even attempt to violate the provided rules or prove properties. However, developers can test the contract logic in a similar way to the onchain environment, to verify the correct program workflow.

The deployment of a smart contract in an environment as much similar to the onchain one, helps the programmers to have a response to the actual behaviour of the software.

Multiple blockchain systems provide a "testnet". This is used for testing and experimentation without risk to real funds or the main chain. It is the same behaviour as the mainnet, but then it has a different purpose and characteristics, for example, the number of native tokens is unlimited.

The network can be virtualised on a machine for development. A tool with this aim is Hardhat, supported by Ethereum Foundation (\cite{HardhatDoc}). This comes built-in with Hardhat Network, a local Ethereum network node designed for development. It provides the option to fork the mainnet, so it is possible to reproduce exactly the real on-chain state. It allows to fork the chain, starting from a specific block.

\section{Discussion}
\label{Discussion}

Since every user on the blockchain can have direct access to smart contracts (and in most cases even to their source code), the security of those is a challenge. The source code might be private, but it is always possible to draw the bytecode; in most projects, for ingratiating the investors, developers publish their source code.

An in-depth approach to scanning bugs is necessary before the deployment. The tools without specification can be very effective in the most common vulnerabilities, such as reentrancy and "out of gas exception". On the other hand, many attacks have recently involved the logic of the program, such as the estimation of rewards for a holder, the creation of a token or the minting (generation) of NFTs. Such similar vulnerabilities cannot be gotten by those, because in this case the property is defined by the developer itself. Tools with specifications come in our help, allowing the tester to provide custom settings involving defined properties.

Machine Learning has been used for the analysis of transactions and for defining specific aspects on-chain. However, its application to the scanning of solidity smart contracts research is not spread as well. Since the amount of data is growing, there are more possibilities that the accuracy of the modules can increase. 

For having a complete overview of the behaviour of a smart contract, it should be deployed in an environment as similar as possible to the mainnet. Most of the tools do not allow inheriting specific onchain information and these should be set up correctly.
The possibility of launching on a testnet, or virtual environment, allows the developer to have a deepen view of the effectiveness of the contract.

The workflow for the correct development of smart contracts should involve a testing phase of their behaviour, and then the usage of tools for verifying the absence of vulnerabilities. Each tool has its limitation and strengths, so it is demanded to the developer chooses the correct ones for computing its customized analysis.

\section{Conclusion}
\label{Conclusion}
Users can create decentralised digital agreements using smart contract technology without the aid of a third party.
Sectors such as health, company management, shareholder agreements, and insurance were drawn to this technology.

However, as this technology's adoption has increased, potential attackers get more interested in it, which leads to several serious exploitations. 
Multiple security strategies adopted in common programs can be used in this context, but smart contracts logic has peculiarities. 
The reason of such amount of attacks can be considered the absence of legal regulation contributes to the increasing number of cyber crimes in this context. The adoption of this technology in more official fields, such as the adoption of a cryptocurrency as the currency of a country, would contribute to the research in security.

In this paper, our research presented the most common vulnerabilities in Solidity smart contracts. Actually, Ethereum and multiple blockchains can adopt different programming languages, but Solidity is the most used one.

We selected analysis tools, describing their strategies, moreover we had an overview of two more strategies. However, more security approaches can be applied in this field and the research is still growing.


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}



\end{document}
\endinput
%%
%% End of file `sample-sigconf-i13n.tex'.
